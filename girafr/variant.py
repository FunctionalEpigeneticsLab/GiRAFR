#!/usr/bin/env python
	

from . import utils
import re
from Bio import SeqIO

#is_10x = False
#cb_tag = 'CB' if is_10x else 'XC'
#umi_tag = 'UB' if is_10x else 'XM'
#gene_tag = 'GN'if is_10x else 'gn'

def call_variants_from_consensus(consensus_bam_in = 'consensus.bam', ref_fasta = 'oligo_pool_plasmid.fa', structure_gtf = 'oligo_pool_plasmid_structure.gtf', is_10x = True):

	"""
	####### Identification of mutations in the gRNA consensus ######## 
	Call mutations from consensus sequence of gRNA library and save into variants dictionary
	Arg:
		bam_in: consensus.bam contains onsensus sequence of gRNA library with cell barcode and umi generated by consensus_sequence.generate_consensus_sequence_gRNA
		ref_fasta: oligo_pool_plasmid.fa
		structure_gtf: oligo_pool_plasmid_structure.gtf
	Return:
		variants = {} 2d dictionary: variants[gene][seq] = [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos)), mismatch]
		gene_mismatches = {} 2d dictionary: gene_mismatches[gene][mismatch] = [variant_nr] 
	"""
	cb_tag = 'CB' if is_10x else 'XC'
	umi_tag = 'UB' if is_10x else 'XM'
	gene_tag = 'GN'if is_10x else 'gn'
	#nm_tag = 'nM' if is_10x else 'NM'

	ref_dict = utils.read_gRNA_reference(ref_fasta, structure_gtf) # ef_dict={} Dictionary ref_dict[gRNA] = reference_sequence
	variants = {}
	gene_mismatches = {} # to add number to mismatches of the same gene
	bam_in = utils.create_bam_infile(consensus_bam_in)
	for r in bam_in:
		is_WT = utils.get_read_tag(r, 'WT')
		gene = utils.get_read_tag(r, gene_tag) # mapped gene name
		if gene == None: # not mapped to gene
			continue
		seq = r.query_sequence
	
		ref_pos = r.get_reference_positions() # a list of reference positions that this read aligns to. 0-base
	
		if is_WT == 'True': # skip wild type
			continue
	
		cigar = r.cigarstring
		nM = utils.get_read_tag(r, 'nM') # number of mismatches

		ref_seq = ref_dict[gene][int(min(ref_pos)):int(max(ref_pos)) + 1] # get reference sequence, [0:5] => from 1st, 2nd, 3rd, and 4th nt. #TODO 
		if (is_10x == False) and (utils.get_read_tag(r,'MD') != None):
			r_seq = r.get_reference_sequence()
			#print('Contain MD, should use MD')
			#exit()

		umi_count = 0 
		if gene not in variants.keys():
			n = 1 # sequence variant type 1
			umi_count = 1
			variants[gene] = {seq: [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos))]}
			mismatch = identify_mismatches(seq, variants[gene][seq])
			
			assert gene not in gene_mismatches.keys() # this gene must not be in gene_mismatches dict as well
			
			# add number to mismatches type for each gene => different sequence variants might have same mismatches type (eg.soft cliping). In this case, should be treated as one mutant type
			variant_nr = gene + '_variant_1'
			gene_mismatches_key = mismatch + '_' + str(min(ref_pos)) # mismatch + str(min(ref_pos)) ensure the same type, situation exist when mismatch the same but sequence and mapping different
			gene_mismatches[gene] = {gene_mismatches_key: variant_nr} 

			variants[gene][seq].append(mismatch) # variants = {} 2d dictionary: variants[gene][seq] = [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos)), mismatch]
		else:
			if seq not in variants[gene].keys():
				n_max = 0
				for variant in variants[gene]:
					if variants[gene][variant][0] > n_max:
						n_max = variants[gene][variant][0]
				n = n_max + 1 # new variant for this gene
				umi_count = 1
				variants[gene][seq] = [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos))]
				mismatch = identify_mismatches(seq, variants[gene][seq])

				gene_mismatches_key = mismatch + '_' + str(min(ref_pos))

				if gene_mismatches_key not in gene_mismatches[gene].keys(): # new mismatch => new gRNA variant type
				#if mismatch not in gene_mismatches[gene].keys(): # new mismatch => new gRNA variant type
					variant_nr = gene + '_variant_'  + str(len(gene_mismatches[gene]) + 1)
					#gene_mismatches[gene][mismatch] = variant_nr
					gene_mismatches[gene][gene_mismatches_key] = variant_nr

				variants[gene][seq].append(mismatch) # variants = {} 2d dictionary: variants[gene][seq] = [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos)), mismatch]

			else: # exist variant
				assert len(variants[gene][seq]) is 7
				umi_count = variants[gene][seq][3] + 1
				variants[gene][seq][3] = umi_count  # umi_count + 1
				# because sequence is the same, therefore, no need to identify_mismatches
	
	return variants, gene_mismatches

def identify_mismatches(variant_seq, variant_attr):
	
	"""Use the cigar info from the consensus.bam to identify mismatch 

	Arg:
		variant_seq: sequence of this variant reads
		variant_attr: [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos))]
	Return:
		mismatch info: eg. 1S42G15T22G6M2S
	"""

	# ref_seq: reference sequence, 10x bam does not contain
	
	assert type(variant_seq) is str
	assert len(variant_attr) is 6

	seq = variant_seq
	cigar = variant_attr[1]
	nM = variant_attr[2]
	umi_count = variant_attr[3]
	ref = variant_attr[4]
	assert type(ref) is str

	cigar_lengths = re.split('M|S|I|D|H|N', cigar) 
	cigar_lengths.remove('')
	cigar_chars = re.split('[0-9]+', cigar)
	cigar_chars.remove('')
	assert len(cigar_lengths) == len(cigar_chars)
	
	pos_q = 0 # query 
	pos_r = 0 # reference
	out = ''
	for i in range(0, len(cigar_chars)):
		if cigar_chars[i] == "M": # match or mismatch
			n = int(cigar_lengths[i])	 
			#print(pos_r)
			#print(pos_q)
			#print(n)
			#print(ref[pos_r: (pos_r+n)])
			#print(seq[pos_q: (pos_q+n)])
			mismatch = utils.compare_two_sequences(ref[pos_r: (pos_r+n)], seq[pos_q: (pos_q+n)])
			pos_q += n
			pos_r += n
			out += mismatch #  mismatch eg: 1A4C
		elif cigar_chars[i] == 'I': #  insertion to the reference: consume query
			n = int(cigar_lengths[i])
			pos_q = pos_q + n # skip n insertion bases
			out += str(n) + 'I' # 2I
		elif cigar_chars[i] == 'D': #  deletion from the reference: consume reference
			n = int(cigar_lengths[i])
			pos_r = pos_r + n # skip n deletion bases
			out += str(n) + 'D'
		elif cigar_chars[i] == 'N': # skipped region from the reference, This is to distinguish between deletions in exons and large skips due to introns
			n = int(cigar_lengths[i])
			pos_r = pos_r + n # skip n bases from reference
			out += str(n) + 'N'
		elif cigar_chars[i] == 'S': #soft clipping: consume query	
			n = int(cigar_lengths[i])
			pos_q = pos_q + n 
			out += str(n) + 'S'
		elif cigar_chars[i] == 'H': # hard clipping: clipped sequences NOTe
			continue
		else:
			print('Unexpected cigar: ')
			print(cigar_chars)
			exit()

	if (nM != None) and len(re.findall('[ATGC]', out)) != nM:
		print(variant_seq, variant_attr, ref)
		print(mismatch, nM)
		print("Found inconsistent number of mismatches as nM tag")
		exit()

	return out

def identify_mismatch_structure(mismatch, structure, gene, variant_attr):
	"""Add plasmid structure to the mismatch ino
	Arg:
		mismatch: mismatch info from  identify_mismatches() eg. 1S42G15T22G6M2S
		structure: dictionary from utils.read_annotation_structure
		gene: 
		variant_attr: [n, cigar, nM, umi_count, ref_seq, int(min(ref_pos)), mismatch]
	Return: 
		mismtach info: eg. gRNA5A2C1AA1ATG1G1 <=> nM:i:8 from the bam	
	"""
	assert len(variant_attr) is 7
	assert mismatch == variant_attr[6]
	
	structure_dict = structure
	ref_pos = variant_attr[5] # 0-based
	mismatch_lengths = re.split('[A-Z]+', mismatch)
	mismatch_chars = re.split('[0-9]+', mismatch)
	mismatch_lengths.remove('')
	mismatch_chars.remove('')
	assert len(mismatch_lengths) == len(mismatch_chars)
	
	#print('ref pos:',ref_pos)
	#print( mismatch_lengths)
	#print( mismatch_chars)
	current_pos = ref_pos # position on reference 
	out = []
	for i in range(0, len(mismatch_chars)):
		if mismatch_chars[i] == 'M': # exact match
			current_pos += int(mismatch_lengths[i])
		elif all([c in ['A','T','G','C'] for c in mismatch_chars[i]]): # mismatch type
			#print(i)
			current_pos += int(mismatch_lengths[i])
			#print('current pos', current_pos) # 0-based
			structure = utils.which_structure(structure_dict, gene, (current_pos+1)) # convert to 1-based as input
			#print(structure)
			relative_pos = current_pos + 1 - structure_dict[gene][structure][1] # +1 is to convert to 1-based so that can minus 1-based structure start
			out.append(str(structure) + ':' + str(relative_pos) + mismatch_chars[i])
			if len(mismatch_chars[i]) != 1: # mismatch is longer than 1 nt
				current_pos += (len(mismatch_chars[i]) -1)  # check if it end in same structure, + ATC = position + 2nt 
				tmp = utils.which_structure(structure_dict, gene, (current_pos+1)) # convert to 1-based as input
				if structure != tmp:
					relative_pos = current_pos + 1 - structure_dict[gene][tmp][1] # +1 is to convert to 1-based so that can minus 1-based structure start
					out.append(str(tmp) + ':' + str(relative_pos) + mismatch_chars[i])
				current_pos += 1 # count current 	
			else:
				current_pos += len(mismatch_chars[i]) # count current  
		elif mismatch_chars[i] == 'I': #  insertion to the reference: consume query
			#current_pos += int(mismatch_lengths[i]) # since insertion does not consume query, so here should not add mismatch lengths to change current position
			structure = utils.which_structure(structure_dict, gene, (current_pos+1)) # convert to 1-based as input
			relative_pos = current_pos + 1 - structure_dict[gene][structure][1] # +1 is to convert to 1-based so that can minus 1-based structure start
			out.append(str(structure) + ':' + str(relative_pos) + mismatch_chars[i] + '(' + str(mismatch_lengths[i]) + ')')
			# not as mismatch, the lengths of intersion is already counted in mismatch_lengths, therefore no need to see if the end stays in same structure
			
		elif mismatch_chars[i] == 'D': #  deletion from the reference: consume reference
			#print('current pos', current_pos)
			current_pos += 0 # the start of deletion
			structure = utils.which_structure(structure_dict, gene, (current_pos+1)) # convert to 1-based as input
			relative_pos = current_pos + 1 - structure_dict[gene][structure][1] # +1 is to convert to 1-based so that can minus 1-based structure start
			out.append(str(structure) + ':' + str(relative_pos) + mismatch_chars[i] + '(' + str(mismatch_lengths[i]) + ')')
			current_pos += int(mismatch_lengths[i])
		elif mismatch_chars[i] == 'S': #soft clipping: consume query
			continue # does not consume ref
		elif mismatch_chars[i] == 'N': # skipped region from the reference, This is to distinguish between deletions in exons and large skips due to introns
			current_pos += int(mismatch_lengths[i]) # consume ref
		else:
			print(mismatch)
			print('Unexpected mismatch type')
			exit()
	return out
	

def call_gRNA_variant(output_dir, consensus_seq_file = 'consensus.sequence.gRNA.txt', ref_fasta = 'oligo_pool_plasmid.fa', structure_gtf = 'oligo_pool_plasmid_structure.gtf', is_10x = True):
	
	"""Call gRNA variant
	Arg:
		consensus_seq_file: consensus.sequence.gRNA.txt generated from consensus_sequence.generate_consensus_sequence_gRNA
		ref_fasta: oligo_pool_plasmid.fa
		structure_gtf: oligo_pool_plasmid_structure.gtf
	Return:
		Write consensus.sequence.gRNA.variant.txt
	"""

	cb_tag = 'CB' if is_10x else 'XC'
	umi_tag = 'UB' if is_10x else 'XM'
	gene_tag = 'GN'if is_10x else 'gn'

	variants, gene_mismatches = call_variants_from_consensus(consensus_bam_in = output_dir + 'consensus.bam', ref_fasta = ref_fasta, structure_gtf = structure_gtf, is_10x = is_10x) 
	structure = utils.read_annotation_structure(structure_gtf)	
	out = open(output_dir + 'consensus.sequence.gRNA.variant.txt', 'w')
	with open(consensus_seq_file, 'r') as consensus_seq_in:
		for l in consensus_seq_in:
			l = l.strip()
			ls = l.split()
			if(l[0] == '#'): # skip header
				continue 
			is_WT = ls[7]
			seq = ls[5] # reads sequence
			gene = ls[8]
			if is_WT == 'True':
				out_line = l + "\tWildType\tNA\n"
				out.write(out_line)
				continue
			if gene == 'multiple': # umi mapped to different genes
				out_line = l + "\tTODO\tNA\n"
				out.write(out_line)
				continue
			if gene == 'None': # TODO
				continue

			try:
				#mismatch = identify_mismatches(seq, variants[gene][seq]) # completed this step at call_variants_from_consensus
				mismatch = variants[gene][seq][6]
				variant_nr = gene_mismatches[gene][mismatch+'_'+str(variants[gene][seq][5])]
				mismatch_structure = identify_mismatch_structure(mismatch, structure, gene, variants[gene][seq])
			except KeyError:
				print("keyError")
				print(variants[gene][seq])
				print(l, gene, seq)
				exit()
			out_line = l + "\t" + variant_nr +":"+mismatch + "\t" + (',').join(mismatch_structure) + "\n"
			out.write(out_line)


if __name__ == '__main__':
	call_gRNA_variant()
